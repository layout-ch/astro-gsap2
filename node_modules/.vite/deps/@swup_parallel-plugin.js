import {
  v
} from "./chunk-QUDU5BP3.js";
import "./chunk-BUSYA2B4.js";

// node_modules/@swup/plugin/dist/index.modern.js
function r() {
  return r = Object.assign ? Object.assign.bind() : function(r2) {
    for (var n3 = 1; n3 < arguments.length; n3++) {
      var e3 = arguments[n3];
      for (var t in e3) Object.prototype.hasOwnProperty.call(e3, t) && (r2[t] = e3[t]);
    }
    return r2;
  }, r.apply(this, arguments);
}
var n = (r2) => String(r2).split(".").map((r3) => String(parseInt(r3 || "0", 10))).concat(["0", "0"]).slice(0, 3).join(".");
var e = class {
  constructor() {
    this.isSwupPlugin = true, this.swup = void 0, this.version = void 0, this.requires = {}, this.handlersToUnregister = [];
  }
  mount() {
  }
  unmount() {
    this.handlersToUnregister.forEach((r2) => r2()), this.handlersToUnregister = [];
  }
  _beforeMount() {
    if (!this.name) throw new Error("You must define a name of plugin when creating a class.");
  }
  _afterUnmount() {
  }
  _checkRequirements() {
    return "object" != typeof this.requires || Object.entries(this.requires).forEach(([r2, e3]) => {
      if (!function(r3, e4, t) {
        const s = function(r4, n3) {
          var e5;
          if ("swup" === r4) return null != (e5 = n3.version) ? e5 : "";
          {
            var t2;
            const e6 = n3.findPlugin(r4);
            return null != (t2 = null == e6 ? void 0 : e6.version) ? t2 : "";
          }
        }(r3, t);
        return !!s && ((r4, e5) => e5.every((e6) => {
          const [, t2, s2] = e6.match(/^([\D]+)?(.*)$/) || [];
          var o, i;
          return ((r5, n3) => {
            const e7 = { "": (r6) => 0 === r6, ">": (r6) => r6 > 0, ">=": (r6) => r6 >= 0, "<": (r6) => r6 < 0, "<=": (r6) => r6 <= 0 };
            return (e7[n3] || e7[""])(r5);
          })((i = s2, o = n(o = r4), i = n(i), o.localeCompare(i, void 0, { numeric: true })), t2 || ">=");
        }))(s, e4);
      }(r2, e3 = Array.isArray(e3) ? e3 : [e3], this.swup)) {
        const n3 = `${r2} ${e3.join(", ")}`;
        throw new Error(`Plugin version mismatch: ${this.name} requires ${n3}`);
      }
    }), true;
  }
  on(r2, n3, e3 = {}) {
    var t;
    n3 = !(t = n3).name.startsWith("bound ") || t.hasOwnProperty("prototype") ? n3.bind(this) : n3;
    const s = this.swup.hooks.on(r2, n3, e3);
    return this.handlersToUnregister.push(s), s;
  }
  once(n3, e3, t = {}) {
    return this.on(n3, e3, r({}, t, { once: true }));
  }
  before(n3, e3, t = {}) {
    return this.on(n3, e3, r({}, t, { before: true }));
  }
  replace(n3, e3, t = {}) {
    return this.on(n3, e3, r({}, t, { replace: true }));
  }
  off(r2, n3) {
    return this.swup.hooks.off(r2, n3);
  }
};

// node_modules/@swup/parallel-plugin/dist/index.modern.js
function n2() {
  return n2 = Object.assign ? Object.assign.bind() : function(t) {
    for (var i = 1; i < arguments.length; i++) {
      var n3 = arguments[i];
      for (var e3 in n3) Object.prototype.hasOwnProperty.call(n3, e3) && (t[e3] = n3[e3]);
    }
    return t;
  }, n2.apply(this, arguments);
}
var e2 = class extends e {
  constructor(i = {}) {
    super(), this.name = "SwupParallelPlugin", this.requires = { swup: ">=4.6" }, this.defaults = { containers: [], keep: 0 }, this.options = void 0, this.originalContainers = null, this.parallelContainers = [], this.startVisit = (t) => {
      this.originalContainers = null, this.visitHasPotentialParallelAnimation(t) && (t.animation.wait = true, t.animation.parallel = true);
    }, this.skipOutAnimation = (t, i2) => {
      this.isParallelVisit(t) && (i2.skip = true);
    }, this.insertContainers = (i2) => {
      if (!this.isParallelVisit(i2)) return;
      const n3 = this.getParallelContainersForVisit(i2);
      this.parallelContainers = n3, this.swup.hooks.call("content:insert", { containers: n3 }, () => {
        for (const { all: e4, next: s, previous: a, keep: o, remove: r2 } of n3) e4.forEach((t, i3) => t.style.setProperty("--swup-parallel-container", `${i3}`)), a.setAttribute("aria-hidden", "true"), a.before(s), i2.animation.animate && (s.classList.add("is-next-container"), v(s), s.classList.remove("is-next-container")), a.classList.add("is-previous-container"), o.forEach((t) => t.classList.add("is-kept-container")), r2.forEach((t) => t.classList.add("is-removing-container"));
      }), this.originalContainers = i2.containers;
      const e3 = this.parallelContainers.map(({ selector: t }) => t);
      i2.containers = i2.containers.filter((t) => !e3.includes(t));
    }, this.resetContainers = (t) => {
      this.originalContainers && (t.containers = this.originalContainers);
    }, this.cleanupContainers = () => {
      const t = this.parallelContainers;
      this.swup.hooks.call("content:remove", { containers: t }, () => {
        for (const { remove: i2, next: n3 } of t) i2.forEach((t2) => t2.remove()), n3.classList.remove("is-next-container");
      }), this.parallelContainers = [];
    }, this.options = n2({}, this.defaults, i);
  }
  mount() {
    this.options.containers.length || (this.options.containers = this.swup.options.containers), this.swup.hooks.create("content:insert"), this.swup.hooks.create("content:remove"), this.on("visit:start", this.startVisit, { priority: 1 }), this.before("animation:out:await", this.skipOutAnimation, { priority: 1 }), this.before("content:replace", this.insertContainers, { priority: 1 }), this.on("content:replace", this.resetContainers), this.on("visit:end", this.cleanupContainers);
  }
  getParallelContainersForVisit(t) {
    const { containers: i } = this.options, n3 = i.filter((i2) => t.containers.includes(i2));
    return n3.length ? n3.reduce((i2, n4) => {
      let { keep: e3 } = this.options;
      e3 = "object" == typeof e3 ? e3[n4] : e3, e3 = Math.max(0, Number(e3));
      const s = t.to.document.querySelector(n4), a = Array.from(document.querySelectorAll(n4)), o = a[0], r2 = a.slice(0, e3), l = a.slice(e3), c = [.../* @__PURE__ */ new Set([s, o, ...r2, ...l])];
      return s && o ? [...i2, { selector: n4, next: s, previous: o, keep: r2, remove: l, all: c }] : (console.warn(`Parallel container ${n4} not found`), i2);
    }, []) : (console.warn("No parallel containers found in list of replaced containers"), []);
  }
  isParallelVisit(t) {
    return t.animation.parallel;
  }
  markVisitAsParallelAnimation(t) {
    t.animation.wait = true, t.animation.parallel = true;
  }
  visitHasPotentialParallelAnimation(t) {
    return false !== t.animation.parallel && this.visitHasParallelContainers(t);
  }
  visitHasParallelContainers(t) {
    return this.options.containers.some((i) => {
      const n3 = document.querySelector(i);
      return null == n3 ? void 0 : n3.matches(t.containers.join(","));
    });
  }
};
export {
  e2 as default
};
//# sourceMappingURL=@swup_parallel-plugin.js.map
