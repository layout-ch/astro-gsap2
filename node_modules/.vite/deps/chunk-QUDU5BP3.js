// node_modules/delegate-it/delegate.js
var ledger = /* @__PURE__ */ new WeakMap();
function editLedger(wanted, baseElement, callback, setup) {
  if (!wanted && !ledger.has(baseElement)) {
    return false;
  }
  const elementMap = ledger.get(baseElement) ?? /* @__PURE__ */ new WeakMap();
  ledger.set(baseElement, elementMap);
  const setups = elementMap.get(callback) ?? /* @__PURE__ */ new Set();
  elementMap.set(callback, setups);
  const existed = setups.has(setup);
  if (wanted) {
    setups.add(setup);
  } else {
    setups.delete(setup);
  }
  return existed && wanted;
}
function safeClosest(event, selector) {
  let target = event.target;
  if (target instanceof Text) {
    target = target.parentElement;
  }
  if (target instanceof Element && event.currentTarget instanceof Element) {
    const closest = target.closest(selector);
    if (closest && event.currentTarget.contains(closest)) {
      return closest;
    }
  }
}
function delegate(selector, type, callback, options = {}) {
  const { signal, base = document } = options;
  if (signal == null ? void 0 : signal.aborted) {
    return;
  }
  const { once, ...nativeListenerOptions } = options;
  const baseElement = base instanceof Document ? base.documentElement : base;
  const capture = Boolean(typeof options === "object" ? options.capture : options);
  const listenerFunction = (event) => {
    const delegateTarget = safeClosest(event, String(selector));
    if (delegateTarget) {
      const delegateEvent = Object.assign(event, { delegateTarget });
      callback.call(baseElement, delegateEvent);
      if (once) {
        baseElement.removeEventListener(type, listenerFunction, nativeListenerOptions);
        editLedger(false, baseElement, callback, setup);
      }
    }
  };
  const setup = JSON.stringify({ selector, type, capture });
  const isAlreadyListening = editLedger(true, baseElement, callback, setup);
  if (!isAlreadyListening) {
    baseElement.addEventListener(type, listenerFunction, nativeListenerOptions);
  }
  signal == null ? void 0 : signal.addEventListener("abort", () => {
    editLedger(false, baseElement, callback, setup);
  });
}
var delegate_default = delegate;

// node_modules/path-to-regexp/dist.es2015/index.js
function lexer(str) {
  var tokens = [];
  var i2 = 0;
  while (i2 < str.length) {
    var char = str[i2];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i2++, value: str[i2++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i2, value: str[i2++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j2 = i2 + 1;
      while (j2 < str.length) {
        var code = str.charCodeAt(j2);
        if (
          // `0-9`
          code >= 48 && code <= 57 || // `A-Z`
          code >= 65 && code <= 90 || // `a-z`
          code >= 97 && code <= 122 || // `_`
          code === 95
        ) {
          name += str[j2++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i2));
      tokens.push({ type: "NAME", index: i2, value: name });
      i2 = j2;
      continue;
    }
    if (char === "(") {
      var count = 1;
      var pattern = "";
      var j2 = i2 + 1;
      if (str[j2] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j2));
      }
      while (j2 < str.length) {
        if (str[j2] === "\\") {
          pattern += str[j2++] + str[j2++];
          continue;
        }
        if (str[j2] === ")") {
          count--;
          if (count === 0) {
            j2++;
            break;
          }
        } else if (str[j2] === "(") {
          count++;
          if (str[j2 + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j2));
          }
        }
        pattern += str[j2++];
      }
      if (count)
        throw new TypeError("Unbalanced pattern at ".concat(i2));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i2));
      tokens.push({ type: "PATTERN", index: i2, value: pattern });
      i2 = j2;
      continue;
    }
    tokens.push({ type: "CHAR", index: i2, value: str[i2++] });
  }
  tokens.push({ type: "END", index: i2, value: "" });
  return tokens;
}
function parse(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a, _b = options.delimiter, delimiter = _b === void 0 ? "/#?" : _b;
  var result = [];
  var key = 0;
  var i2 = 0;
  var path = "";
  var tryConsume = function(type) {
    if (i2 < tokens.length && tokens[i2].type === type)
      return tokens[i2++].value;
  };
  var mustConsume = function(type) {
    var value2 = tryConsume(type);
    if (value2 !== void 0)
      return value2;
    var _a2 = tokens[i2], nextType = _a2.type, index = _a2.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
  };
  var consumeText = function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  };
  var isSafe = function(value2) {
    for (var _i = 0, delimiter_1 = delimiter; _i < delimiter_1.length; _i++) {
      var char2 = delimiter_1[_i];
      if (value2.indexOf(char2) > -1)
        return true;
    }
    return false;
  };
  var safePattern = function(prefix2) {
    var prev = result[result.length - 1];
    var prevText = prefix2 || (prev && typeof prev === "string" ? prev : "");
    if (prev && !prevText) {
      throw new TypeError('Must have text between two parameters, missing text after "'.concat(prev.name, '"'));
    }
    if (!prevText || isSafe(prevText))
      return "[^".concat(escapeString(delimiter), "]+?");
    return "(?:(?!".concat(escapeString(prevText), ")[^").concat(escapeString(delimiter), "])+?");
  };
  while (i2 < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || safePattern(prefix),
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path += value;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? safePattern(prefix) : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
function match(str, options) {
  var keys = [];
  var re = pathToRegexp(str, keys, options);
  return regexpToFunction(re, keys, options);
}
function regexpToFunction(re, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.decode, decode = _a === void 0 ? function(x2) {
    return x2;
  } : _a;
  return function(pathname) {
    var m2 = re.exec(pathname);
    if (!m2)
      return false;
    var path = m2[0], index = m2.index;
    var params = /* @__PURE__ */ Object.create(null);
    var _loop_1 = function(i3) {
      if (m2[i3] === void 0)
        return "continue";
      var key = keys[i3 - 1];
      if (key.modifier === "*" || key.modifier === "+") {
        params[key.name] = m2[i3].split(key.prefix + key.suffix).map(function(value) {
          return decode(value, key);
        });
      } else {
        params[key.name] = decode(m2[i3], key);
      }
    };
    for (var i2 = 1; i2 < m2.length; i2++) {
      _loop_1(i2);
    }
    return { path, index, params };
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys) {
  if (!keys)
    return path;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index = 0;
  var execResult = groupsRegex.exec(path.source);
  while (execResult) {
    keys.push({
      // Use parenthesized substring match if available, index otherwise
      name: execResult[1] || index++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path.source);
  }
  return path;
}
function arrayToRegexp(paths, keys, options) {
  var parts = paths.map(function(path) {
    return pathToRegexp(path, keys, options).source;
  });
  return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
function stringToRegexp(path, keys, options) {
  return tokensToRegexp(parse(path, options), keys, options);
}
function tokensToRegexp(tokens, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x2) {
    return x2;
  } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
  var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
  var delimiterRe = "[".concat(escapeString(delimiter), "]");
  var route = start ? "^" : "";
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    if (typeof token === "string") {
      route += escapeString(encode(token));
    } else {
      var prefix = escapeString(encode(token.prefix));
      var suffix = escapeString(encode(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod = token.modifier === "*" ? "?" : "";
            route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
          } else {
            route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
          }
        } else {
          if (token.modifier === "+" || token.modifier === "*") {
            throw new TypeError('Can not repeat "'.concat(token.name, '" without a prefix and suffix'));
          }
          route += "(".concat(token.pattern, ")").concat(token.modifier);
        }
      } else {
        route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
      }
    }
  }
  if (end) {
    if (!strict)
      route += "".concat(delimiterRe, "?");
    route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
    }
    if (!isEndDelimited) {
      route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
    }
  }
  return new RegExp(route, flags(options));
}
function pathToRegexp(path, keys, options) {
  if (path instanceof RegExp)
    return regexpToRegexp(path, keys);
  if (Array.isArray(path))
    return arrayToRegexp(path, keys, options);
  return stringToRegexp(path, keys, options);
}

// node_modules/swup/dist/Swup.modern.js
function i() {
  return i = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var i2 = arguments[e];
      for (var s2 in i2) ({}).hasOwnProperty.call(i2, s2) && (t[s2] = i2[s2]);
    }
    return t;
  }, i.apply(null, arguments);
}
var s = (t, e) => String(t).toLowerCase().replace(/[\s/_.]+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+|-+$/g, "") || e || "";
var n = ({ hash: t } = {}) => window.location.pathname + window.location.search + (t ? window.location.hash : "");
var o = (t, e = {}) => {
  const s2 = i({ url: t = t || n({ hash: true }), random: Math.random(), source: "swup" }, e);
  window.history.pushState(s2, "", t);
};
var r = (t = null, e = {}) => {
  t = t || n({ hash: true });
  const s2 = i({}, window.history.state || {}, { url: t, random: Math.random(), source: "swup" }, e);
  window.history.replaceState(s2, "", t);
};
var a = (e, s2, n2, o2) => {
  const r2 = new AbortController();
  return o2 = i({}, o2, { signal: r2.signal }), delegate_default(e, s2, n2, o2), { destroy: () => r2.abort() };
};
var l = class _l extends URL {
  constructor(t, e = document.baseURI) {
    super(t.toString(), e), Object.setPrototypeOf(this, _l.prototype);
  }
  get url() {
    return this.pathname + this.search;
  }
  static fromElement(t) {
    const e = t.getAttribute("href") || t.getAttribute("xlink:href") || "";
    return new _l(e);
  }
  static fromUrl(t) {
    return new _l(t);
  }
};
var h = (t, i2) => {
  try {
    return match(t, i2);
  } catch (e) {
    throw new Error(`[swup] Error parsing path "${String(t)}":
${String(e)}`);
  }
};
var c = class extends Error {
  constructor(t, e) {
    super(t), this.url = void 0, this.status = void 0, this.aborted = void 0, this.timedOut = void 0, this.name = "FetchError", this.url = e.url, this.status = e.status, this.aborted = e.aborted || false, this.timedOut = e.timedOut || false;
  }
};
async function u(t, e = {}) {
  var s2;
  t = l.fromUrl(t).url;
  const { visit: n2 = this.visit } = e, o2 = i({}, this.options.requestHeaders, e.headers), r2 = null != (s2 = e.timeout) ? s2 : this.options.timeout, a2 = new AbortController(), { signal: h2 } = a2;
  e = i({}, e, { headers: o2, signal: h2 });
  let u2, d2 = false, p2 = null;
  r2 && r2 > 0 && (p2 = setTimeout(() => {
    d2 = true, a2.abort("timeout");
  }, r2));
  try {
    u2 = await this.hooks.call("fetch:request", n2, { url: t, options: e }, (t2, { url: e2, options: i2 }) => fetch(e2, i2)), p2 && clearTimeout(p2);
  } catch (e2) {
    if (d2) throw this.hooks.call("fetch:timeout", n2, { url: t }), new c(`Request timed out: ${t}`, { url: t, timedOut: d2 });
    if ("AbortError" === (null == e2 ? void 0 : e2.name) || h2.aborted) throw new c(`Request aborted: ${t}`, { url: t, aborted: true });
    throw e2;
  }
  const { status: m2, url: w2 } = u2, g2 = await u2.text();
  if (500 === m2) throw this.hooks.call("fetch:error", n2, { status: m2, response: u2, url: w2 }), new c(`Server error: ${w2}`, { status: m2, url: w2 });
  if (!g2) throw new c(`Empty response: ${w2}`, { status: m2, url: w2 });
  const { url: f2 } = l.fromUrl(w2), v2 = { url: f2, html: g2 };
  return !n2.cache.write || e.method && "GET" !== e.method || t !== f2 || this.cache.set(v2.url, v2), v2;
}
var d = class {
  constructor(t) {
    this.swup = void 0, this.pages = /* @__PURE__ */ new Map(), this.swup = t;
  }
  get size() {
    return this.pages.size;
  }
  get all() {
    const t = /* @__PURE__ */ new Map();
    return this.pages.forEach((e, s2) => {
      t.set(s2, i({}, e));
    }), t;
  }
  has(t) {
    return this.pages.has(this.resolve(t));
  }
  get(t) {
    const e = this.pages.get(this.resolve(t));
    return e ? i({}, e) : e;
  }
  set(t, e) {
    e = i({}, e, { url: t = this.resolve(t) }), this.pages.set(t, e), this.swup.hooks.callSync("cache:set", void 0, { page: e });
  }
  update(t, e) {
    t = this.resolve(t);
    const s2 = i({}, this.get(t), e, { url: t });
    this.pages.set(t, s2);
  }
  delete(t) {
    this.pages.delete(this.resolve(t));
  }
  clear() {
    this.pages.clear(), this.swup.hooks.callSync("cache:clear", void 0, void 0);
  }
  prune(t) {
    this.pages.forEach((e, i2) => {
      t(i2, e) && this.delete(i2);
    });
  }
  resolve(t) {
    const { url: e } = l.fromUrl(t);
    return this.swup.resolveUrl(e);
  }
};
var p = (t, e = document) => e.querySelector(t);
var m = (t, e = document) => Array.from(e.querySelectorAll(t));
var w = () => new Promise((t) => {
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      t();
    });
  });
});
function g(t) {
  return !!t && ("object" == typeof t || "function" == typeof t) && "function" == typeof t.then;
}
function f(t, e = []) {
  return new Promise((i2, s2) => {
    const n2 = t(...e);
    g(n2) ? n2.then(i2, s2) : i2(n2);
  });
}
function v(t) {
  var e;
  null == (e = t = t || document.body) || e.getBoundingClientRect();
}
function y(t, e) {
  const i2 = null == t ? void 0 : t.closest(`[${e}]`);
  return null != i2 && i2.hasAttribute(e) ? (null == i2 ? void 0 : i2.getAttribute(e)) || true : void 0;
}
var k = class {
  constructor(t) {
    this.swup = void 0, this.swupClasses = ["to-", "is-changing", "is-rendering", "is-popstate", "is-animating", "is-leaving"], this.swup = t;
  }
  get selectors() {
    const { scope: t } = this.swup.visit.animation;
    return "containers" === t ? this.swup.visit.containers : "html" === t ? ["html"] : Array.isArray(t) ? t : [];
  }
  get selector() {
    return this.selectors.join(",");
  }
  get targets() {
    return this.selector.trim() ? m(this.selector) : [];
  }
  add(...t) {
    this.targets.forEach((e) => e.classList.add(...t));
  }
  remove(...t) {
    this.targets.forEach((e) => e.classList.remove(...t));
  }
  clear() {
    this.targets.forEach((t) => {
      const e = t.className.split(" ").filter((t2) => this.isSwupClass(t2));
      t.classList.remove(...e);
    });
  }
  isSwupClass(t) {
    return this.swupClasses.some((e) => t.startsWith(e));
  }
};
var b = class {
  constructor(t, e) {
    this.id = void 0, this.state = void 0, this.from = void 0, this.to = void 0, this.containers = void 0, this.animation = void 0, this.trigger = void 0, this.cache = void 0, this.history = void 0, this.scroll = void 0;
    const { to: i2, from: s2, hash: n2, el: o2, event: r2 } = e;
    this.id = Math.random(), this.state = 1, this.from = { url: null != s2 ? s2 : t.location.url, hash: t.location.hash }, this.to = { url: i2, hash: n2 }, this.containers = t.options.containers, this.animation = { animate: true, wait: false, name: void 0, native: t.options.native, scope: t.options.animationScope, selector: t.options.animationSelector }, this.trigger = { el: o2, event: r2 }, this.cache = { read: t.options.cache, write: t.options.cache }, this.history = { action: "push", popstate: false, direction: void 0 }, this.scroll = { reset: true, target: void 0 };
  }
  advance(t) {
    this.state < t && (this.state = t);
  }
  abort() {
    this.state = 8;
  }
  get done() {
    return this.state >= 7;
  }
};
function S(t) {
  return new b(this, t);
}
var E = class {
  constructor(t) {
    this.swup = void 0, this.registry = /* @__PURE__ */ new Map(), this.hooks = ["animation:out:start", "animation:out:await", "animation:out:end", "animation:in:start", "animation:in:await", "animation:in:end", "animation:skip", "cache:clear", "cache:set", "content:replace", "content:scroll", "enable", "disable", "fetch:request", "fetch:error", "fetch:timeout", "history:popstate", "link:click", "link:self", "link:anchor", "link:newtab", "page:load", "page:view", "scroll:top", "scroll:anchor", "visit:start", "visit:transition", "visit:abort", "visit:end"], this.swup = t, this.init();
  }
  init() {
    this.hooks.forEach((t) => this.create(t));
  }
  create(t) {
    this.registry.has(t) || this.registry.set(t, /* @__PURE__ */ new Map());
  }
  exists(t) {
    return this.registry.has(t);
  }
  get(t) {
    const e = this.registry.get(t);
    if (e) return e;
    console.error(`Unknown hook '${t}'`);
  }
  clear() {
    this.registry.forEach((t) => t.clear());
  }
  on(t, e, s2 = {}) {
    const n2 = this.get(t);
    if (!n2) return console.warn(`Hook '${t}' not found.`), () => {
    };
    const o2 = i({}, s2, { id: n2.size + 1, hook: t, handler: e });
    return n2.set(e, o2), () => this.off(t, e);
  }
  before(t, e, s2 = {}) {
    return this.on(t, e, i({}, s2, { before: true }));
  }
  replace(t, e, s2 = {}) {
    return this.on(t, e, i({}, s2, { replace: true }));
  }
  once(t, e, s2 = {}) {
    return this.on(t, e, i({}, s2, { once: true }));
  }
  off(t, e) {
    const i2 = this.get(t);
    i2 && e ? i2.delete(e) || console.warn(`Handler for hook '${t}' not found.`) : i2 && i2.clear();
  }
  async call(t, e, i2, s2) {
    const [n2, o2, r2] = this.parseCallArgs(t, e, i2, s2), { before: a2, handler: l2, after: h2 } = this.getHandlers(t, r2);
    await this.run(a2, n2, o2);
    const [c2] = await this.run(l2, n2, o2, true);
    return await this.run(h2, n2, o2), this.dispatchDomEvent(t, n2, o2), c2;
  }
  callSync(t, e, i2, s2) {
    const [n2, o2, r2] = this.parseCallArgs(t, e, i2, s2), { before: a2, handler: l2, after: h2 } = this.getHandlers(t, r2);
    this.runSync(a2, n2, o2);
    const [c2] = this.runSync(l2, n2, o2, true);
    return this.runSync(h2, n2, o2), this.dispatchDomEvent(t, n2, o2), c2;
  }
  parseCallArgs(t, e, i2, s2) {
    return e instanceof b || "object" != typeof e && "function" != typeof i2 ? [e, i2, s2] : [void 0, e, i2];
  }
  async run(t, e = this.swup.visit, i2, s2 = false) {
    const n2 = [];
    for (const { hook: o2, handler: r2, defaultHandler: a2, once: l2 } of t) if (null == e || !e.done) {
      l2 && this.off(o2, r2);
      try {
        const t2 = await f(r2, [e, i2, a2]);
        n2.push(t2);
      } catch (t2) {
        if (s2) throw t2;
        console.error(`Error in hook '${o2}':`, t2);
      }
    }
    return n2;
  }
  runSync(t, e = this.swup.visit, i2, s2 = false) {
    const n2 = [];
    for (const { hook: o2, handler: r2, defaultHandler: a2, once: l2 } of t) if (null == e || !e.done) {
      l2 && this.off(o2, r2);
      try {
        const t2 = r2(e, i2, a2);
        n2.push(t2), g(t2) && console.warn(`Swup will not await Promises in handler for synchronous hook '${o2}'.`);
      } catch (t2) {
        if (s2) throw t2;
        console.error(`Error in hook '${o2}':`, t2);
      }
    }
    return n2;
  }
  getHandlers(t, e) {
    const i2 = this.get(t);
    if (!i2) return { found: false, before: [], handler: [], after: [], replaced: false };
    const s2 = Array.from(i2.values()), n2 = this.sortRegistrations, o2 = s2.filter(({ before: t2, replace: e2 }) => t2 && !e2).sort(n2), r2 = s2.filter(({ replace: t2 }) => t2).filter((t2) => true).sort(n2), a2 = s2.filter(({ before: t2, replace: e2 }) => !t2 && !e2).sort(n2), l2 = r2.length > 0;
    let h2 = [];
    if (e && (h2 = [{ id: 0, hook: t, handler: e }], l2)) {
      const i3 = r2.length - 1, s3 = (t2) => {
        const i4 = r2[t2 - 1];
        return i4 ? (e2, n3) => i4.handler(e2, n3, s3(t2 - 1)) : e;
      };
      h2 = [{ id: 0, hook: t, handler: r2[i3].handler, defaultHandler: s3(i3) }];
    }
    return { found: true, before: o2, handler: h2, after: a2, replaced: l2 };
  }
  sortRegistrations(t, e) {
    var i2, s2;
    return (null != (i2 = t.priority) ? i2 : 0) - (null != (s2 = e.priority) ? s2 : 0) || t.id - e.id || 0;
  }
  dispatchDomEvent(t, e, i2) {
    if (null != e && e.done) return;
    const s2 = { hook: t, args: i2, visit: e || this.swup.visit };
    document.dispatchEvent(new CustomEvent("swup:any", { detail: s2, bubbles: true })), document.dispatchEvent(new CustomEvent(`swup:${t}`, { detail: s2, bubbles: true }));
  }
};
var C = (t) => {
  if (t && "#" === t.charAt(0) && (t = t.substring(1)), !t) return null;
  const e = decodeURIComponent(t);
  let i2 = document.getElementById(t) || document.getElementById(e) || p(`a[name='${CSS.escape(t)}']`) || p(`a[name='${CSS.escape(e)}']`);
  return i2 || "top" !== t || (i2 = document.body), i2;
};
var U = "transition";
var P = "animation";
async function $({ selector: t, elements: e }) {
  if (false === t && !e) return;
  let i2 = [];
  if (e) i2 = Array.from(e);
  else if (t && (i2 = m(t, document.body), !i2.length)) return void console.warn(`[swup] No elements found matching animationSelector \`${t}\``);
  const s2 = i2.map((t2) => function(t3) {
    const { type: e2, timeout: i3, propCount: s3 } = function(t4) {
      const e3 = window.getComputedStyle(t4), i4 = x(e3, `${U}Delay`), s4 = x(e3, `${U}Duration`), n2 = A(i4, s4), o2 = x(e3, `${P}Delay`), r2 = x(e3, `${P}Duration`), a2 = A(o2, r2), l2 = Math.max(n2, a2), h2 = l2 > 0 ? n2 > a2 ? U : P : null;
      return { type: h2, timeout: l2, propCount: h2 ? h2 === U ? s4.length : r2.length : 0 };
    }(t3);
    return !(!e2 || !i3) && new Promise((n2) => {
      const o2 = `${e2}end`, r2 = performance.now();
      let a2 = 0;
      const l2 = () => {
        t3.removeEventListener(o2, h2), n2();
      }, h2 = (e3) => {
        e3.target === t3 && ((performance.now() - r2) / 1e3 < e3.elapsedTime || ++a2 >= s3 && l2());
      };
      setTimeout(() => {
        a2 < s3 && l2();
      }, i3 + 1), t3.addEventListener(o2, h2);
    });
  }(t2));
  s2.filter(Boolean).length > 0 ? await Promise.all(s2) : t && console.warn(`[swup] No CSS animation duration defined on elements matching \`${t}\``);
}
function x(t, e) {
  return (t[e] || "").split(", ");
}
function A(t, e) {
  for (; t.length < e.length; ) t = t.concat(t);
  return Math.max(...e.map((e2, i2) => H(e2) + H(t[i2])));
}
function H(t) {
  return 1e3 * parseFloat(t);
}
function V(t, e = {}, s2 = {}) {
  if ("string" != typeof t) throw new Error("swup.navigate() requires a URL parameter");
  if (this.shouldIgnoreVisit(t, { el: s2.el, event: s2.event })) return void window.location.assign(t);
  const { url: n2, hash: o2 } = l.fromUrl(t), r2 = this.createVisit(i({}, s2, { to: n2, hash: o2 }));
  this.performNavigation(r2, e);
}
async function I(t, e = {}) {
  if (this.navigating) {
    if (this.visit.state >= 6) return t.state = 2, void (this.onVisitEnd = () => this.performNavigation(t, e));
    await this.hooks.call("visit:abort", this.visit, void 0), delete this.visit.to.document, this.visit.state = 8;
  }
  this.navigating = true, this.visit = t;
  const { el: i2 } = t.trigger;
  e.referrer = e.referrer || this.location.url, false === e.animate && (t.animation.animate = false), t.animation.animate || this.classes.clear();
  const n2 = e.history || y(i2, "data-swup-history");
  "string" == typeof n2 && ["push", "replace"].includes(n2) && (t.history.action = n2);
  const a2 = e.animation || y(i2, "data-swup-animation");
  var h2, c2;
  "string" == typeof a2 && (t.animation.name = a2), "object" == typeof e.cache ? (t.cache.read = null != (h2 = e.cache.read) ? h2 : t.cache.read, t.cache.write = null != (c2 = e.cache.write) ? c2 : t.cache.write) : void 0 !== e.cache && (t.cache = { read: !!e.cache, write: !!e.cache }), delete e.cache;
  try {
    await this.hooks.call("visit:start", t, void 0), t.state = 3;
    const i3 = this.hooks.call("page:load", t, { options: e }, async (t2, e2) => {
      let i4;
      return t2.cache.read && (i4 = this.cache.get(t2.to.url)), e2.page = i4 || await this.fetchPage(t2.to.url, e2.options), e2.cache = !!i4, e2.page;
    });
    i3.then(({ html: e2 }) => {
      t.advance(5), t.to.html = e2, t.to.document = new DOMParser().parseFromString(e2, "text/html");
    });
    const n3 = t.to.url + t.to.hash;
    if (t.history.popstate || ("replace" === t.history.action || t.to.url === this.location.url ? r(n3) : (this.currentHistoryIndex++, o(n3, { index: this.currentHistoryIndex }))), this.location = l.fromUrl(n3), t.history.popstate && this.classes.add("is-popstate"), t.animation.name && this.classes.add(`to-${s(t.animation.name)}`), t.animation.wait && await i3, t.done) return;
    if (await this.hooks.call("visit:transition", t, void 0, async () => {
      if (!t.animation.animate) return await this.hooks.call("animation:skip", void 0), void await this.renderPage(t, await i3);
      t.advance(4), await this.animatePageOut(t), t.animation.native && document.startViewTransition ? await document.startViewTransition(async () => await this.renderPage(t, await i3)).finished : await this.renderPage(t, await i3), await this.animatePageIn(t);
    }), t.done) return;
    await this.hooks.call("visit:end", t, void 0, () => this.classes.clear()), t.state = 7, this.navigating = false, this.onVisitEnd && (this.onVisitEnd(), this.onVisitEnd = void 0);
  } catch (e2) {
    if (!e2 || null != e2 && e2.aborted) return void (t.state = 8);
    t.state = 9, console.error(e2), this.options.skipPopStateHandling = () => (window.location.assign(t.to.url + t.to.hash), true), window.history.back();
  } finally {
    delete t.to.document;
  }
}
var L = async function(t) {
  await this.hooks.call("animation:out:start", t, void 0, () => {
    this.classes.add("is-changing", "is-animating", "is-leaving");
  }), await this.hooks.call("animation:out:await", t, { skip: false }, (t2, { skip: e }) => {
    if (!e) return this.awaitAnimations({ selector: t2.animation.selector });
  }), await this.hooks.call("animation:out:end", t, void 0);
};
var q = function(t) {
  var e;
  const i2 = t.to.document;
  if (!i2) return false;
  const s2 = (null == (e = i2.querySelector("title")) ? void 0 : e.innerText) || "";
  document.title = s2;
  const n2 = m('[data-swup-persist]:not([data-swup-persist=""])'), o2 = t.containers.map((t2) => {
    const e2 = document.querySelector(t2), s3 = i2.querySelector(t2);
    return e2 && s3 ? (e2.replaceWith(s3.cloneNode(true)), true) : (e2 || console.warn(`[swup] Container missing in current document: ${t2}`), s3 || console.warn(`[swup] Container missing in incoming document: ${t2}`), false);
  }).filter(Boolean);
  return n2.forEach((t2) => {
    const e2 = t2.getAttribute("data-swup-persist"), i3 = p(`[data-swup-persist="${e2}"]`);
    i3 && i3 !== t2 && i3.replaceWith(t2);
  }), o2.length === t.containers.length;
};
var R = function(t) {
  const e = { behavior: "auto" }, { target: s2, reset: n2 } = t.scroll, o2 = null != s2 ? s2 : t.to.hash;
  let r2 = false;
  return o2 && (r2 = this.hooks.callSync("scroll:anchor", t, { hash: o2, options: e }, (t2, { hash: e2, options: i2 }) => {
    const s3 = this.getAnchorElement(e2);
    return s3 && s3.scrollIntoView(i2), !!s3;
  })), n2 && !r2 && (r2 = this.hooks.callSync("scroll:top", t, { options: e }, (t2, { options: e2 }) => (window.scrollTo(i({ top: 0, left: 0 }, e2)), true))), r2;
};
var T = async function(t) {
  if (t.done) return;
  const e = this.hooks.call("animation:in:await", t, { skip: false }, (t2, { skip: e2 }) => {
    if (!e2) return this.awaitAnimations({ selector: t2.animation.selector });
  });
  await w(), await this.hooks.call("animation:in:start", t, void 0, () => {
    this.classes.remove("is-animating");
  }), await e, await this.hooks.call("animation:in:end", t, void 0);
};
var N = async function(t, e) {
  if (t.done) return;
  t.advance(6);
  const { url: i2 } = e;
  this.isSameResolvedUrl(n(), i2) || (r(i2), this.location = l.fromUrl(i2), t.to.url = this.location.url, t.to.hash = this.location.hash), await this.hooks.call("content:replace", t, { page: e }, (t2, {}) => {
    if (this.classes.remove("is-leaving"), t2.animation.animate && this.classes.add("is-rendering"), !this.replaceContent(t2)) throw new Error("[swup] Container mismatch, aborting");
    t2.animation.animate && (this.classes.add("is-changing", "is-animating", "is-rendering"), t2.animation.name && this.classes.add(`to-${s(t2.animation.name)}`));
  }), await this.hooks.call("content:scroll", t, void 0, () => this.scrollToContent(t)), await this.hooks.call("page:view", t, { url: this.location.url, title: document.title });
};
var O = function(t) {
  var e;
  if (e = t, Boolean(null == e ? void 0 : e.isSwupPlugin)) {
    if (t.swup = this, !t._checkRequirements || t._checkRequirements()) return t._beforeMount && t._beforeMount(), t.mount(), this.plugins.push(t), this.plugins;
  } else console.error("Not a swup plugin instance", t);
};
function D(t) {
  const e = this.findPlugin(t);
  if (e) return e.unmount(), e._afterUnmount && e._afterUnmount(), this.plugins = this.plugins.filter((t2) => t2 !== e), this.plugins;
  console.error("No such plugin", e);
}
function M(t) {
  return this.plugins.find((e) => e === t || e.name === t || e.name === `Swup${String(t)}`);
}
function W(t) {
  if ("function" != typeof this.options.resolveUrl) return console.warn("[swup] options.resolveUrl expects a callback function."), t;
  const e = this.options.resolveUrl(t);
  return e && "string" == typeof e ? e.startsWith("//") || e.startsWith("http") ? (console.warn("[swup] options.resolveUrl needs to return a relative url"), t) : e : (console.warn("[swup] options.resolveUrl needs to return a url"), t);
}
function B(t, e) {
  return this.resolveUrl(t) === this.resolveUrl(e);
}
var _ = { animateHistoryBrowsing: false, animationSelector: '[class*="transition-"]', animationScope: "html", cache: true, containers: ["#swup"], ignoreVisit: (t, { el: e } = {}) => !(null == e || !e.closest("[data-no-swup]")), linkSelector: "a[href]", linkToSelf: "scroll", native: false, plugins: [], resolveUrl: (t) => t, requestHeaders: { "X-Requested-With": "swup", Accept: "text/html, application/xhtml+xml" }, skipPopStateHandling: (t) => {
  var e;
  return "swup" !== (null == (e = t.state) ? void 0 : e.source);
}, timeout: 0 };
var j = class {
  get currentPageUrl() {
    return this.location.url;
  }
  constructor(t = {}) {
    var e, s2;
    this.version = "4.7.0", this.options = void 0, this.defaults = _, this.plugins = [], this.visit = void 0, this.cache = void 0, this.hooks = void 0, this.classes = void 0, this.location = l.fromUrl(window.location.href), this.currentHistoryIndex = void 0, this.clickDelegate = void 0, this.navigating = false, this.onVisitEnd = void 0, this.use = O, this.unuse = D, this.findPlugin = M, this.log = () => {
    }, this.navigate = V, this.performNavigation = I, this.createVisit = S, this.delegateEvent = a, this.fetchPage = u, this.awaitAnimations = $, this.renderPage = N, this.replaceContent = q, this.animatePageIn = T, this.animatePageOut = L, this.scrollToContent = R, this.getAnchorElement = C, this.getCurrentUrl = n, this.resolveUrl = W, this.isSameResolvedUrl = B, this.options = i({}, this.defaults, t), this.handleLinkClick = this.handleLinkClick.bind(this), this.handlePopState = this.handlePopState.bind(this), this.cache = new d(this), this.classes = new k(this), this.hooks = new E(this), this.visit = this.createVisit({ to: "" }), this.currentHistoryIndex = null != (e = null == (s2 = window.history.state) ? void 0 : s2.index) ? e : 1, this.enable();
  }
  async enable() {
    var t;
    const { linkSelector: e } = this.options;
    this.clickDelegate = this.delegateEvent(e, "click", this.handleLinkClick), window.addEventListener("popstate", this.handlePopState), this.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), this.options.native = this.options.native && !!document.startViewTransition, this.options.plugins.forEach((t2) => this.use(t2)), "swup" !== (null == (t = window.history.state) ? void 0 : t.source) && r(null, { index: this.currentHistoryIndex }), await w(), await this.hooks.call("enable", void 0, void 0, () => {
      const t2 = document.documentElement;
      t2.classList.add("swup-enabled"), t2.classList.toggle("swup-native", this.options.native);
    });
  }
  async destroy() {
    this.clickDelegate.destroy(), window.removeEventListener("popstate", this.handlePopState), this.cache.clear(), this.options.plugins.forEach((t) => this.unuse(t)), await this.hooks.call("disable", void 0, void 0, () => {
      const t = document.documentElement;
      t.classList.remove("swup-enabled"), t.classList.remove("swup-native");
    }), this.hooks.clear();
  }
  shouldIgnoreVisit(t, { el: e, event: i2 } = {}) {
    const { origin: s2, url: n2, hash: o2 } = l.fromUrl(t);
    return s2 !== window.location.origin || !(!e || !this.triggerWillOpenNewWindow(e)) || !!this.options.ignoreVisit(n2 + o2, { el: e, event: i2 });
  }
  handleLinkClick(t) {
    const e = t.delegateTarget, { href: i2, url: s2, hash: n2 } = l.fromElement(e);
    if (this.shouldIgnoreVisit(i2, { el: e, event: t })) return;
    if (this.navigating && s2 === this.visit.to.url) return void t.preventDefault();
    const o2 = this.createVisit({ to: s2, hash: n2, el: e, event: t });
    t.metaKey || t.ctrlKey || t.shiftKey || t.altKey ? this.hooks.callSync("link:newtab", o2, { href: i2 }) : 0 === t.button && this.hooks.callSync("link:click", o2, { el: e, event: t }, () => {
      var e2;
      const i3 = null != (e2 = o2.from.url) ? e2 : "";
      t.preventDefault(), s2 && s2 !== i3 ? this.isSameResolvedUrl(s2, i3) || this.performNavigation(o2) : n2 ? this.hooks.callSync("link:anchor", o2, { hash: n2 }, () => {
        r(s2 + n2), this.scrollToContent(o2);
      }) : this.hooks.callSync("link:self", o2, void 0, () => {
        "navigate" === this.options.linkToSelf ? this.performNavigation(o2) : (r(s2), this.scrollToContent(o2));
      });
    });
  }
  handlePopState(t) {
    var e, i2, s2, o2;
    const r2 = null != (e = null == (i2 = t.state) ? void 0 : i2.url) ? e : window.location.href;
    if (this.options.skipPopStateHandling(t)) return;
    if (this.isSameResolvedUrl(n(), this.location.url)) return;
    const { url: a2, hash: h2 } = l.fromUrl(r2), c2 = this.createVisit({ to: a2, hash: h2, event: t });
    c2.history.popstate = true;
    const u2 = null != (s2 = null == (o2 = t.state) ? void 0 : o2.index) ? s2 : 0;
    u2 && u2 !== this.currentHistoryIndex && (c2.history.direction = u2 - this.currentHistoryIndex > 0 ? "forwards" : "backwards", this.currentHistoryIndex = u2), c2.animation.animate = false, c2.scroll.reset = false, c2.scroll.target = false, this.options.animateHistoryBrowsing && (c2.animation.animate = true, c2.scroll.reset = true), this.hooks.callSync("history:popstate", c2, { event: t }, () => {
      this.performNavigation(c2);
    });
  }
  triggerWillOpenNewWindow(t) {
    return !!t.matches('[download], [target="_blank"]');
  }
};

export {
  s,
  n,
  o,
  r,
  a,
  l,
  h,
  p,
  m,
  w,
  g,
  f,
  v,
  y,
  j
};
//# sourceMappingURL=chunk-QUDU5BP3.js.map
