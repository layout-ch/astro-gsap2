{
  "version": 3,
  "sources": ["../../@swup/plugin/src/versionSatisfies.ts", "../../@swup/plugin/src/index.ts", "../../@swup/plugin/src/pluginRequirements.ts", "../../@swup/parallel-plugin/src/index.ts"],
  "sourcesContent": ["type Comparator = '>' | '>=' | '<' | '<=';\n\n// Fill versions to exactly 3 decimals\nexport const normalizeVersion = (version: string): string => {\n\treturn String(version)\n\t\t.split('.')\n\t\t.map(segment => String(parseInt(segment || '0', 10)))\n\t\t.concat(['0', '0'])\n\t\t.slice(0, 3)\n\t\t.join('.');\n};\n\n// Numerically compare version strings after normalizing them\nexport const compareVersion = (a: string, b: string): number => {\n\ta = normalizeVersion(a);\n\tb = normalizeVersion(b);\n\treturn a.localeCompare(b, undefined, { numeric: true });\n};\n\n// Apply a comparator (equals, greater-than, etc) by its symbol to a sort comparison\nconst applyComparator = (comparisonResult: number, comparator: Comparator) => {\n\tconst comparators = {\n\t\t'': (r: number) => r === 0,\n\t\t'>': (r: number) => r > 0,\n\t\t'>=': (r: number) => r >= 0,\n\t\t'<': (r: number) => r < 0,\n\t\t'<=': (r: number) => r <= 0\n\t};\n\tconst comparatorFn = comparators[comparator] || comparators[''];\n\treturn comparatorFn(comparisonResult);\n};\n\n/**\n * Check if a version satisfies all given version requirements\n *\n * versionSatisfies('2.1.0', ['>=2', '<4']) // true\n * versionSatisfies('2.1.0', ['5']) // false\n *\n * @param {string} installed Installed version\n * @param {Array.<string>} requirements Array of requirements that must be satisfied\n * @returns boolean\n */\nexport const versionSatisfies = (installed: string, requirements: string[]) => {\n\treturn requirements.every((required) => {\n\t\tconst [, comparator, version] = required.match(/^([\\D]+)?(.*)$/) || [];\n\t\tconst comparisonResult = compareVersion(installed, version);\n\t\treturn applyComparator(comparisonResult, (comparator as Comparator) || '>=');\n\t});\n};\n", "import type Swup from 'swup';\nimport type { Plugin, HookName, HookOptions, HookUnregister, Handler } from 'swup';\nimport { checkDependencyVersion } from './pluginRequirements.js';\n\nfunction isBound(func: Function) {\n\treturn func.name.startsWith('bound ') && !func.hasOwnProperty('prototype');\n}\n\nexport default abstract class SwupPlugin implements Plugin {\n\t/** Name of the plugin */\n\tabstract name: string;\n\n\t/** Identify as a swup plugin */\n\tisSwupPlugin: true = true;\n\n\t// Swup instance, assigned by swup itself\n\tswup: Swup;\n\t/** Version of this plugin. Currently not in use, defined here for backward compatiblity. */\n\tversion?: string;\n\n\t/** Version requirements of this plugin. Example: `{ swup: '>=4' }` */\n\trequires?: Record<string, string | string[]> = {};\n\n\t// List of hook handlers to unregister on unmount\n\tprivate handlersToUnregister: HookUnregister[] = [];\n\n\t/** Run on mount */\n\tmount() {\n\t\t// this is mount method rewritten by class extending\n\t\t// and is executed when swup is enabled with plugin\n\t}\n\n\t/** Run on unmount */\n\tunmount() {\n\t\t// this is unmount method rewritten by class extending\n\t\t// and is executed when swup with plugin is disabled\n\n\t\t// Unsubscribe all registered hook handlers\n\t\tthis.handlersToUnregister.forEach((unregister) => unregister());\n\t\tthis.handlersToUnregister = [];\n\t}\n\n\t_beforeMount(): void {\n\t\tif (!this.name) {\n\t\t\tthrow new Error('You must define a name of plugin when creating a class.');\n\t\t}\n\t}\n\n\t_afterUnmount(): void {\n\t\t// here for any future hidden auto-cleanup\n\t}\n\n\t_checkRequirements(): boolean {\n\t\tif (typeof this.requires !== 'object') {\n\t\t\treturn true;\n\t\t}\n\n\t\tObject.entries(this.requires).forEach(([dependency, versions]) => {\n\t\t\tversions = Array.isArray(versions) ? versions : [versions];\n\t\t\tif (!checkDependencyVersion(dependency, versions, this.swup)) {\n\t\t\t\tconst requirement = `${dependency} ${versions.join(', ')}`;\n\t\t\t\tthrow new Error(`Plugin version mismatch: ${this.name} requires ${requirement}`);\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Register a new hook handler.\n\t *\n\t * On plugin unmount, the handler will automatically be unregistered.\n\t * The handler function is lexically bound to the plugin instance for convenience.\n\t * @see swup.hooks.on\n\t */\n\tprotected on<T extends HookName>(hook: T, handler: Handler<T>, options: HookOptions = {}): HookUnregister {\n\t\thandler = !isBound(handler) ? handler.bind(this) : handler;\n\t\tconst unregister = this.swup.hooks.on(hook, handler, options);\n\t\tthis.handlersToUnregister.push(unregister);\n\t\treturn unregister;\n\t}\n\n\tprotected once<T extends HookName>(hook: T, handler: Handler<T>, options: HookOptions = {}): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, once: true });\n\t}\n\n\tprotected before<T extends HookName>(hook: T, handler: Handler<T>, options: HookOptions = {}): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, before: true });\n\t}\n\n\tprotected replace<T extends HookName>(hook: T, handler: Handler<T>, options: HookOptions = {}): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, replace: true });\n\t}\n\n\tprotected off<T extends HookName>(hook: T, handler?: Handler<T>): void {\n\t\treturn this.swup.hooks.off(hook, handler!);\n\t}\n}\n", "import type Swup from 'swup';\n\nimport { versionSatisfies } from './versionSatisfies.js';\n\nfunction getInstalledDependencyVersion(dependency: string, swup: Swup): string {\n\tif (dependency === 'swup') {\n\t\treturn swup.version ?? '';\n\t} else {\n\t\t// Circular type dependency?\n\t\t// findPlugin returns swup's Plugin type which is not up-to-date\n\t\t// with the actual Plugin type from index.ts\n\t\tconst plugin = swup.findPlugin(dependency);\n\t\treturn plugin?.version ?? '';\n\t}\n}\n\nexport function checkDependencyVersion(\n\tdependency: string,\n\trequirements: string[],\n\tswup: Swup\n): boolean {\n\tconst version = getInstalledDependencyVersion(dependency, swup);\n\tif (version) {\n\t\treturn versionSatisfies(version, requirements);\n\t} else {\n\t\treturn false;\n\t}\n}\n", "import type { Handler, PageData, Visit } from 'swup';\nimport { forceReflow } from 'swup';\nimport Plugin from '@swup/plugin';\n\ndeclare module 'swup' {\n\texport interface HookDefinitions {\n\t\t'content:insert': { containers: ContainerSet[] };\n\t\t'content:remove': { containers: ContainerSet[] };\n\t}\n\texport interface VisitAnimation {\n\t\t/** Parallel visit: run in and out animation at the same time */\n\t\tparallel?: boolean;\n\t}\n}\n\ntype PluginOptions = {\n\t/** Containers to animate in parallel */\n\tcontainers: string[];\n\t/** Number of previous containers to keep around after the animation */\n\tkeep: number | { [container: string]: number };\n};\n\ntype ContainerSet = {\n\t/** Selector to match this container */\n\tselector: string;\n\t/** Incoming container element */\n\tnext: HTMLElement;\n\t/** Outgoing container element */\n\tprevious: HTMLElement;\n\t/** Container elements to keep around after the animation */\n\tkeep: HTMLElement[];\n\t/** Container elements to remove after the animation */\n\tremove: HTMLElement[];\n\t/** All container elements associated with this selector */\n\tall: HTMLElement[];\n};\n\nexport default class SwupParallelPlugin extends Plugin {\n\tname = 'SwupParallelPlugin';\n\n\trequires = { swup: '>=4.6' };\n\n\tdefaults: PluginOptions = {\n\t\tcontainers: [],\n\t\tkeep: 0\n\t};\n\n\toptions: PluginOptions;\n\n\toriginalContainers: string[] | null = null;\n\tparallelContainers: ContainerSet[] = [];\n\n\tconstructor(options: Partial<PluginOptions> = {}) {\n\t\tsuper();\n\t\tthis.options = { ...this.defaults, ...options };\n\t}\n\n\tmount() {\n\t\t// No containers passed? Use all content containers\n\t\tif (!this.options.containers.length) {\n\t\t\tthis.options.containers = this.swup.options.containers;\n\t\t}\n\n\t\t// Create new hooks\n\t\tthis.swup.hooks.create('content:insert');\n\t\tthis.swup.hooks.create('content:remove');\n\n\t\t// On visit: check for containers and mark as parallel visit\n\t\t// Run after user hooks to allow disabling parallel animations beforehand\n\t\tthis.on('visit:start', this.startVisit, { priority: 1 });\n\n\t\t// Before awaiting out animation: skip\n\t\tthis.before('animation:out:await', this.skipOutAnimation, { priority: 1 });\n\n\t\t// Before content replace: insert new containers\n\t\tthis.before('content:replace', this.insertContainers, { priority: 1 });\n\n\t\t// After content replace: reset containers\n\t\tthis.on('content:replace', this.resetContainers);\n\n\t\t// After visit: remove old containers\n\t\tthis.on('visit:end', this.cleanupContainers);\n\t}\n\n\t/** On visit start: mark visit as parallel if conditions match */\n\tprotected startVisit: Handler<'visit:start'> = (visit) => {\n\t\tthis.originalContainers = null;\n\n\t\t// Only mark as parallel visit if containers found and animation matches\n\t\tif (this.visitHasPotentialParallelAnimation(visit)) {\n\t\t\tvisit.animation.wait = true;\n\t\t\tvisit.animation.parallel = true;\n\t\t}\n\t};\n\n\t/** On animation out: skip animation if parallel visit */\n\tprotected skipOutAnimation: Handler<'animation:out:await'> = (visit, args) => {\n\t\tif (this.isParallelVisit(visit)) {\n\t\t\targs.skip = true;\n\t\t}\n\t};\n\n\t/** Before content replacement: insert new containers */\n\tprotected insertContainers: Handler<'content:replace'> = (visit) => {\n\t\tif (!this.isParallelVisit(visit)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Get info about parallel containers and save for later cleanup\n\t\tconst containers = this.getParallelContainersForVisit(visit);\n\t\tthis.parallelContainers = containers;\n\n\t\t// Replace parallel containers ourselves\n\t\tthis.swup.hooks.call('content:insert', { containers }, () => {\n\t\t\tfor (const { all, next, previous, keep, remove } of containers) {\n\t\t\t\tall.forEach((el, i) => el.style.setProperty('--swup-parallel-container', `${i}`));\n\t\t\t\tprevious.setAttribute('aria-hidden', 'true');\n\t\t\t\tprevious.before(next);\n\n\t\t\t\tif (visit.animation.animate) {\n\t\t\t\t\tnext.classList.add('is-next-container');\n\t\t\t\t\tforceReflow(next);\n\t\t\t\t\tnext.classList.remove('is-next-container');\n\t\t\t\t}\n\n\t\t\t\tprevious.classList.add('is-previous-container');\n\t\t\t\tkeep.forEach((el) => el.classList.add('is-kept-container'));\n\t\t\t\tremove.forEach((el) => el.classList.add('is-removing-container'));\n\t\t\t}\n\t\t});\n\n\t\t// Modify visit containers so swup will only replace non-parallel containers\n\t\tthis.originalContainers = visit.containers;\n\t\tconst parallelSelectors = this.parallelContainers.map(({ selector }) => selector);\n\t\tvisit.containers = visit.containers.filter((s) => !parallelSelectors.includes(s));\n\t};\n\n\t/** After content replacement: restore original container selectors */\n\tprotected resetContainers: Handler<'content:replace'> = (visit) => {\n\t\tif (this.originalContainers) {\n\t\t\tvisit.containers = this.originalContainers;\n\t\t}\n\t};\n\n\t/** After each visit: remove previous containers */\n\tprotected cleanupContainers = () => {\n\t\tconst containers = this.parallelContainers;\n\t\tthis.swup.hooks.call('content:remove', { containers }, () => {\n\t\t\tfor (const { remove, next } of containers) {\n\t\t\t\tremove.forEach((el) => el.remove());\n\t\t\t\tnext.classList.remove('is-next-container');\n\t\t\t}\n\t\t});\n\t\tthis.parallelContainers = [];\n\t};\n\n\t/** Get all container sets for this visit from the current page and the incoming html */\n\tprotected getParallelContainersForVisit(visit: Visit): ContainerSet[] {\n\t\tconst { containers: parallelContainers } = this.options;\n\n\t\tconst containersInVisit = parallelContainers.filter((s) => visit.containers.includes(s));\n\t\tif (!containersInVisit.length) {\n\t\t\tconsole.warn('No parallel containers found in list of replaced containers');\n\t\t\treturn [];\n\t\t}\n\n\t\treturn containersInVisit.reduce((containers, selector: string) => {\n\t\t\tlet { keep: keepCount } = this.options;\n\t\t\tkeepCount = typeof keepCount === 'object' ? keepCount[selector] : keepCount;\n\t\t\tkeepCount = Math.max(0, Number(keepCount));\n\n\t\t\tconst next = visit.to.document!.querySelector<HTMLElement>(selector);\n\t\t\tconst previousAll = Array.from(document.querySelectorAll<HTMLElement>(selector));\n\n\t\t\tconst previous = previousAll[0];\n\t\t\tconst keep = previousAll.slice(0, keepCount);\n\t\t\tconst remove = previousAll.slice(keepCount);\n\t\t\tconst all = [...new Set([next!, previous, ...keep, ...remove])];\n\t\t\tif (next && previous) {\n\t\t\t\treturn [...containers, { selector, next, previous, keep, remove, all }];\n\t\t\t} else {\n\t\t\t\tconsole.warn(`Parallel container ${selector} not found`);\n\t\t\t\treturn containers;\n\t\t\t}\n\t\t}, [] as ContainerSet[]);\n\t}\n\n\t/** Check if a visit is marked as parallel animation */\n\tprotected isParallelVisit(visit: Visit) {\n\t\treturn visit.animation.parallel;\n\t}\n\n\t/** Mark a visit as parallel animation */\n\tprotected markVisitAsParallelAnimation(visit: Visit) {\n\t\tvisit.animation.wait = true;\n\t\tvisit.animation.parallel = true;\n\t}\n\n\t/** Check if a visit is potentially parallel */\n\tprotected visitHasPotentialParallelAnimation(visit: Visit) {\n\t\t// Checking for visit.animation.parallel !== false here allows explicitly\n\t\t// disabling parallel animations in user hooks before this plugin executes\n\t\treturn visit.animation.parallel !== false && this.visitHasParallelContainers(visit);\n\t}\n\n\t/** Check if any of a visit's containers are animated in parallel */\n\tprotected visitHasParallelContainers(visit: Visit) {\n\t\treturn this.options.containers.some((selector) => {\n\t\t\tconst container = document.querySelector(selector);\n\t\t\treturn container?.matches(visit.containers.join(','));\n\t\t});\n\t}\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;AAGO,IAAsBA,IAAIC,CAAAA,OACzBC,OAAOD,EAAAA,EACZE,MAAM,GAAA,EACNC,IAAIC,CAAAA,OAAWH,OAAOI,SAASD,MAAW,KAAK,EAAA,CAAA,CAAA,EAC/CE,OAAO,CAAC,KAAK,GAAA,CAAA,EACbC,MAAM,GAAG,CAAA,EACTC,KAAK,GAAA;ACDsBC,IAAAA,IAAAA,MAAAA;EAK7BC,cAAAA;AAAAA,SAAAA,eAAAA,MAAyBC,KAGzBC,OAAAA,QAEAZ,KAAAA,UAAAA,QAAAA,KAGAa,WAA+C,CAAA,GAAA,KAGvCC,uBAAyC,CAAA;EAAE;EAGnDC,QAAAA;EAMAC;EAAAA,UAAAA;AAKCL,SAAKG,qBAAqBG,QAASC,CAAAA,OAAeA,GAAAA,CAAAA,GAClDP,KAAKG,uBAAuB,CAAA;EAC7B;EAEAK,eAAAA;AACC,QAAA,CAAKR,KAAKS,KACT,OAAUC,IAAAA,MAAM,yDAAA;EAElB;EAEAC,gBAAAA;EAAAA;EAIAC,qBAAAA;AACC,WAA6B,YAAA,OAAdZ,KAACE,YAIhBW,OAAOC,QAAQd,KAAKE,QAAAA,EAAUI,QAAQ,CAAA,CAAES,IAAYC,EAAAA,MAAAA;AAEnD,UAAA,CC3CaC,SACfF,IACAG,IACAjB,GAAAA;AAEA,cAAaZ,IAjBd,SAAuC0B,IAAoBd,IAAAA;AAAAA,cAAAA;AAC1D,cAAmB,WAAfc,GACH,QAAA,SAAOd,KAAAA,GAAKZ,WAAAA,KAAW;AACjB;AAIN,gBAAA8B;AAAA,kBAAAC,KAAenB,GAAKoB,WAAWN,EAAAA;AAC/B,mBAAsB,SAAfO,KAAAA,QAAAA,KAAAA,SAAAA,GAAQjC,WAAO8B,KAAI;UAC1B;QACF,EAO+CJ,IAAYd,CAAAA;AAC1D,eAAA,CAAA,CAAIZ,MFoB2B,CAACkC,IAAmBL,OAChCA,GAACM,MAAOC,CAAAA,OAAAA;AAC1B,gBAAA,CAASC,EAAAA,IAAYrC,EAAAA,IAAWoC,GAASE,MAAM,gBAAA,KAAqB,CAAA;AA/BxC,cAACC,GAAWC;AAiCxC,kBA1BsB,CAACC,IAA0BJ,OAAAA;AAClD,kBAAiBK,KAAG,EACnB,IAAKC,CAAAA,OAAoB,MAANA,IACnB,KAAMA,CAAAA,OAAcA,KAAI,GACxB,MAAOA,CAAAA,OAAcA,MAAK,GAC1B,KAAMA,CAAAA,OAAcA,KAAI,GACxB,MAAOA,CAAAA,OAAcA,MAAK,EAAA;AAG3B,oBADqBD,GAAYL,EAAAA,KAAeK,GAAY,EAAA,GACxCD,EAAAA;UAAgB,IAhBKD,IAgCWxC,IA/BpDuC,IAAIxC,EAD0BwC,IAgCWL,EAAAA,GA9BzCM,IAAIzC,EAAiByC,CAAAA,GACdD,EAAEK,cAAcJ,GAAAA,QAAc,EAAEK,SAAAA,KAAS,CAAA,IA8BLR,MAA6B,IAAA;QAAI,CAAA,GEvBnDrC,GAAS6B,EAAAA;MAInC,EDgC+BH,IAD5BC,KAAWmB,MAAMC,QAAQpB,EAAAA,IAAYA,KAAW,CAACA,EAAAA,GACChB,KAAKC,IAAAA,GAAO;AAC7D,cAAiBoC,KAAM,GAAAtB,EAAAA,IAAcC,GAASnB,KAAK,IAAA,CAAA;AACnD,cAAA,IAAea,MAA6B,4BAAAV,KAAKS,IAAAA,aAAiB4B,EAAAA,EAAAA;MAClE;IAAA,CAAA,GAAA;EAIH;EASUC,GAAuBC,IAASC,IAAqBC,KAAuB,CAAA,GAAA;AAvEvF,QAAiBC;AAwEfF,IAAAA,KAAAA,EAxEeE,IAwEIF,IAvER/B,KAAKkC,WAAW,QAAA,KAAcD,EAAKE,eAAe,WAAA,IAuE/BJ,GAAQK,KAAK7C,IAAAA,IAAQwC;AACnD,UAAgBjC,IAAGP,KAAKC,KAAK6C,MAAMR,GAAGC,IAAMC,IAASC,EAAAA;AAErD,WADAzC,KAAKG,qBAAqB4C,KAAKxC,CAAAA,GAAAA;EAEhC;EAEUyC,KAAyBT,IAASC,IAAqBC,IAAuB,CAAA,GAAA;AACvF,WAAA,KAAYH,GAAGC,IAAMC,IAAOS,EAAA,CAAA,GAAOR,GAASO,EAAAA,MAAAA,KAAM,CAAA,CAAA;EACnD;EAEUE,OAA2BX,IAASC,IAAqBC,IAAuB,CAAA,GAAA;AACzF,WAAWzC,KAACsC,GAAGC,IAAMC,IAAOS,EAAA,CAAA,GAAOR,GAASS,EAAAA,QAAAA,KAAQ,CAAA,CAAA;EACrD;EAEUC,QAA4BZ,IAASC,IAAqBC,IAAuB,CAAA,GAAA;AAC1F,WAAA,KAAYH,GAAGC,IAAMC,IAAOS,EAAA,CAAA,GAAOR,GAASU,EAAAA,SAAAA,KAAS,CAAA,CAAA;EACtD;EAEUC,IAAwBb,IAASC,IAAAA;AAC1C,WAAWxC,KAACC,KAAK6C,MAAMM,IAAIb,IAAMC,EAAAA;EAClC;AAAA;;;;;;;;;;;;AE3DoB,IAAAa,KAAA,cAA2BC,EAAAA;EAe/CC,YAAYC,IAAkC,CAAE,GAAA;AAC/CC,UAAAA,GAAQC,KAfTC,OAAO,sBAAA,KAEPC,WAAW,EAAEC,MAAM,QAAA,GAEnBC,KAAAA,WAA0B,EACzBC,YAAY,CAAA,GACZC,MAAM,EAAA,GAGPR,KAAAA,UAAAA,QAAAA,KAEAS,qBAAsC,MAAIP,KAC1CQ,qBAAqC,CAAA,GAmC3BC,KAAAA,aAAsCC,OAAAA;AAC/CV,WAAKO,qBAAqB,MAGtBP,KAAKW,mCAAmCD,CAAAA,MAC3CA,EAAME,UAAUC,OAAAA,MAChBH,EAAME,UAAUE,WAAAA;IAChB,GAIQC,KAAAA,mBAAmD,CAACL,GAAOM,OAAAA;AAChEhB,WAAKiB,gBAAgBP,CAAAA,MACxBM,GAAKE,OAAAA;IACL,GACDlB,KAGSmB,mBAAgDT,CAAAA,OAAAA;AACzD,UAAA,CAAKV,KAAKiB,gBAAgBP,EAAAA,EACzB;AAID,YAAML,KAAaL,KAAKoB,8BAA8BV,EAAAA;AACtDV,WAAKQ,qBAAqBH,IAG1BL,KAAKG,KAAKkB,MAAMC,KAAK,kBAAkB,EAAEjB,YAAAA,GAAAA,GAAc,MAAA;AACtD,mBAAK,EAAMkB,KAAEA,IAAGC,MAAEA,GAAIC,UAAEA,GAAQnB,MAAEA,GAAIoB,QAAEA,GAAAA,KAAYrB,GACnDkB,CAAAA,GAAII,QAAQ,CAACC,GAAIC,OAAMD,EAAGE,MAAMC,YAAY,6BAAA,GAAgCF,EAAAA,EAAAA,CAAAA,GAC5EJ,EAASO,aAAa,eAAe,MAAA,GACrCP,EAASQ,OAAOT,CAAAA,GAEZd,GAAME,UAAUsB,YACnBV,EAAKW,UAAUC,IAAI,mBAAA,GACnBC,EAAYb,CAAAA,GACZA,EAAKW,UAAUT,OAAO,mBAAA,IAGvBD,EAASU,UAAUC,IAAI,uBAAA,GACvB9B,EAAKqB,QAASC,OAAOA,EAAGO,UAAUC,IAAI,mBAAA,CAAA,GACtCV,GAAOC,QAASC,OAAOA,EAAGO,UAAUC,IAAI,uBAAA,CAAA;MACxC,CAAA,GAIFpC,KAAKO,qBAAqBG,GAAML;AAChC,YAAMiC,KAAoBtC,KAAKQ,mBAAmB+B,IAAI,CAAA,EAAGC,UAAAA,EAAAA,MAAeA,CAAAA;AACxE9B,MAAAA,GAAML,aAAaK,GAAML,WAAWoC,OAAQC,OAAAA,CAAOJ,GAAkBK,SAASD,CAAAA,CAAAA;IAAE,GAChF1C,KAGS4C,kBAA+ClC,OAAAA;AACpDV,WAAKO,uBACRG,EAAML,aAAaL,KAAKO;IACxB,GAIQsC,KAAAA,oBAAoB,MAAA;AAC7B,YAAMxC,IAAaL,KAAKQ;AACxBR,WAAKG,KAAKkB,MAAMC,KAAK,kBAAkB,EAAEjB,YAAAA,EAAAA,GAAc,MAAA;AACtD,mBAAK,EAAMqB,QAAEA,IAAMF,MAAEA,GAAAA,KAAUnB,EAC9BqB,CAAAA,GAAOC,QAASC,CAAAA,OAAOA,GAAGF,OAAAA,CAAAA,GAC1BF,GAAKW,UAAUT,OAAO,mBAAA;MACtB,CAAA,GAEF1B,KAAKQ,qBAAqB,CAAA;IAC3B,GApGCR,KAAKF,UAAOgD,GAAA,CAAA,GAAQ9C,KAAKI,UAAaN,CAAAA;EACvC;EAEAiD,QAAAA;AAEM/C,SAAKF,QAAQO,WAAW2C,WAC5BhD,KAAKF,QAAQO,aAAaL,KAAKG,KAAKL,QAAQO,aAI7CL,KAAKG,KAAKkB,MAAM4B,OAAO,gBAAA,GACvBjD,KAAKG,KAAKkB,MAAM4B,OAAO,gBAAA,GAIvBjD,KAAKkD,GAAG,eAAelD,KAAKS,YAAY,EAAE0C,UAAU,EAAA,CAAA,GAGpDnD,KAAKiC,OAAO,uBAAuBjC,KAAKe,kBAAkB,EAAEoC,UAAU,EAAA,CAAA,GAGtEnD,KAAKiC,OAAO,mBAAmBjC,KAAKmB,kBAAkB,EAAEgC,UAAU,EAAA,CAAA,GAGlEnD,KAAKkD,GAAG,mBAAmBlD,KAAK4C,eAAAA,GAGhC5C,KAAKkD,GAAG,aAAalD,KAAK6C,iBAAAA;EAC3B;EA2EUzB,8BAA8BV,GAAAA;AACvC,UAAA,EAAQL,YAAYG,EAAAA,IAAuBR,KAAKF,SAE1CsD,KAAoB5C,EAAmBiC,OAAQC,CAAAA,OAAMhC,EAAML,WAAWsC,SAASD,EAAAA,CAAAA;AACrF,WAAKU,GAAkBJ,SAKhBI,GAAkBC,OAAO,CAAChD,IAAYmC,OAAAA;AAC5C,UAAA,EAAMlC,MAAMgD,GAAAA,IAActD,KAAKF;AAC/BwD,MAAAA,KAAiC,YAAA,OAAdA,KAAyBA,GAAUd,EAAAA,IAAYc,IAClEA,KAAYC,KAAKC,IAAI,GAAGC,OAAOH,EAAAA,CAAAA;AAE/B,YAAM9B,IAAOd,EAAMgD,GAAGC,SAAUC,cAA2BpB,EAAAA,GACrDqB,IAAcC,MAAMC,KAAKJ,SAASK,iBAA8BxB,EAAAA,CAAAA,GAEhEf,IAAWoC,EAAY,CAAA,GACvBvD,KAAOuD,EAAYI,MAAM,GAAGX,EAAAA,GAC5B5B,IAASmC,EAAYI,MAAMX,EAAAA,GAC3B/B,IAAM,CAAA,GAAI,oBAAI2C,IAAI,CAAC1C,GAAOC,GAAAA,GAAanB,IAAAA,GAASoB,CAAAA,CAAAA,CAAAA;AACtD,aAAIF,KAAQC,IACJ,CAAA,GAAIpB,IAAY,EAAEmC,UAAAA,IAAUhB,MAAAA,GAAMC,UAAAA,GAAUnB,MAAAA,IAAMoB,QAAAA,GAAQH,KAAAA,EAAAA,CAAAA,KAEjE4C,QAAQC,KAAAA,sBAA2B5B,EAAAA,YAAAA,GAC5BnC;IACP,GACC,CAAA,CAAA,KAtBF8D,QAAQC,KAAK,6DAAA,GACN,CAAA;EAsBT;EAGUnD,gBAAgBP,GAAAA;AACzB,WAAOA,EAAME,UAAUE;EACxB;EAGUuD,6BAA6B3D,GAAAA;AACtCA,MAAME,UAAUC,OAAAA,MAChBH,EAAME,UAAUE,WAAAA;EACjB;EAGUH,mCAAmCD,GAAAA;AAG5C,WAAA,UAAOA,EAAME,UAAUE,YAAsBd,KAAKsE,2BAA2B5D,CAAAA;EAC9E;EAGU4D,2BAA2B5D,GAAAA;AACpC,WAAOV,KAAKF,QAAQO,WAAWkE,KAAM/B,OAAAA;AACpC,YAAMgC,KAAYb,SAASC,cAAcpB,CAAAA;AACzC,aAAgB,QAATgC,KAAAA,SAAAA,GAAWC,QAAQ/D,EAAML,WAAWqE,KAAK,GAAA,CAAA;IAAI,CAAA;EAEtD;AAAA;",
  "names": ["normalizeVersion", "version", "String", "split", "map", "segment", "parseInt", "concat", "slice", "join", "SwupPlugin", "isSwupPlugin", "this", "swup", "requires", "handlersToUnregister", "mount", "unmount", "forEach", "unregister", "_beforeMount", "name", "Error", "_afterUnmount", "_checkRequirements", "Object", "entries", "dependency", "versions", "checkDependencyVersion", "requirements", "_plugin$version", "e", "findPlugin", "plugin", "installed", "every", "required", "comparator", "match", "a", "b", "comparisonResult", "comparators", "r", "localeCompare", "numeric", "Array", "isArray", "requirement", "on", "hook", "handler", "options", "func", "startsWith", "hasOwnProperty", "bind", "hooks", "push", "once", "_extends", "before", "replace", "off", "SwupParallelPlugin", "Plugin", "constructor", "options", "super", "this", "name", "requires", "swup", "defaults", "containers", "keep", "originalContainers", "parallelContainers", "startVisit", "visit", "visitHasPotentialParallelAnimation", "animation", "wait", "parallel", "skipOutAnimation", "args", "isParallelVisit", "skip", "insertContainers", "getParallelContainersForVisit", "hooks", "call", "all", "next", "previous", "remove", "forEach", "el", "i", "style", "setProperty", "setAttribute", "before", "animate", "classList", "add", "forceReflow", "parallelSelectors", "map", "selector", "filter", "s", "includes", "resetContainers", "cleanupContainers", "_extends", "mount", "length", "create", "on", "priority", "containersInVisit", "reduce", "keepCount", "Math", "max", "Number", "to", "document", "querySelector", "previousAll", "Array", "from", "querySelectorAll", "slice", "Set", "console", "warn", "markVisitAsParallelAnimation", "visitHasParallelContainers", "some", "container", "matches", "join"]
}
